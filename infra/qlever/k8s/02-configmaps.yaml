---
# QLever Configuration (non-sensitive)
apiVersion: v1
kind: ConfigMap
metadata:
  name: qlever-config
  namespace: qlever
  labels:
    app.kubernetes.io/name: qlever
    app.kubernetes.io/component: sparql-database
data:
  # Config file generation
  QLEVER_GENERATE_CONFIG_FILE: "true"

  # [data]
  QLEVER_DATA_NAME: "local"
  QLEVER_DATA_DESCRIPTION: "Local dataset for QLever"

  # [index]
  QLEVER_INDEX_INPUT_FILES: "../input/**/*.ttl"
  QLEVER_INDEX_CAT_INPUT_FILES: "cat ../input/**/*.ttl"
  QLEVER_INDEX_PARALLEL_PARSING: "false"
  QLEVER_INDEX_SETTINGS_JSON: '{ "ascii-prefixes-only": false, "num-triples-per-batch": 100000 }'

  # [server]
  QLEVER_SERVER_HOST_NAME: "0.0.0.0"
  QLEVER_SERVER_PORT: "7001"
  QLEVER_SERVER_MEMORY_FOR_QUERIES: "8G"
  QLEVER_SERVER_CACHE_MAX_SIZE: "4G"
  QLEVER_SERVER_TIMEOUT: "300s"

  # [runtime]
  QLEVER_RUNTIME_SYSTEM: "native"

  # Entrypoint behavior
  SHOULD_DOWNLOAD: "false"
  FORCE_DOWNLOAD: "false"
  SHOULD_INDEX: "true"
  FORCE_INDEXING: "false"
  STOP_ON_CALL_ENABLED: "false"
  START_ADDITIONAL_ARGS: ""

  # User/Group IDs (used by init container)
  UID: "1000"
  GID: "1000"

---
# QLever Scripts (read-only)
apiVersion: v1
kind: ConfigMap
metadata:
  name: qlever-scripts
  namespace: qlever
  labels:
    app.kubernetes.io/name: qlever
    app.kubernetes.io/component: sparql-database
data:
  generate-qleverfile.sh: |
    #!/bin/sh
    set -eu

    ##################################################################################
    # This script generates a Qleverfile that can be used to start a QLever instance #
    ##################################################################################

    QLEVER_FILE_PATH="${QLEVER_FILE_PATH:-/data/Qleverfile}"

    # Have a way to opt-out of generating the Qleverfile
    QLEVER_GENERATE_CONFIG_FILE="${QLEVER_GENERATE_CONFIG_FILE:-true}"
    if [ "${QLEVER_GENERATE_CONFIG_FILE}" = "auto" ]; then
      # Check if the Qleverfile already exists
      if [ -f "${QLEVER_FILE_PATH}" ]; then
        echo "INFO: Skipping Qleverfile generation, as 'QLEVER_GENERATE_CONFIG_FILE' is set to 'auto' and the file already exists at '${QLEVER_FILE_PATH}'"
        exit 0
      else
        echo "INFO: Generating Qleverfile, as 'QLEVER_GENERATE_CONFIG_FILE' is set to 'auto' and the file does not exist at '${QLEVER_FILE_PATH}'"
        QLEVER_GENERATE_CONFIG_FILE="true"
      fi
    fi

    if [ "${QLEVER_GENERATE_CONFIG_FILE}" != "true" ]; then
      echo "INFO: Skipping Qleverfile generation, as 'QLEVER_GENERATE_CONFIG_FILE' is not set to 'true'"
      exit 0
    fi

    dirname "${QLEVER_FILE_PATH}" | xargs mkdir -p

    # Set default values for some configuration fields (could be overridden by other environment variables)
    export QLEVER_DATA_NAME="${QLEVER_DATA_NAME:-default}"
    export QLEVER_DATA_DESCRIPTION="${QLEVER_DATA_DESCRIPTION:-Default dataset}"

    export QLEVER_INDEX_SETTINGS_JSON="${QLEVER_INDEX_SETTINGS_JSON:-{ \"ascii-prefixes-only\": false, \"num-triples-per-batch\": 100000 }}"
    export QLEVER_INDEX_PARALLEL_PARSING="${QLEVER_INDEX_PARALLEL_PARSING:-true}"

    export QLEVER_SERVER_ACCESS_TOKEN="${QLEVER_SERVER_ACCESS_TOKEN:-${QLEVER_DATA_NAME}_7643543846_Zs6nw7yi3Z9m}"
    export QLEVER_SERVER_HOST_NAME="${QLEVER_SERVER_HOST_NAME:-127.0.0.1}"
    export QLEVER_SERVER_PORT="${QLEVER_SERVER_PORT:-7001}"
    export QLEVER_SERVER_MEMORY_FOR_QUERIES="${QLEVER_SERVER_MEMORY_FOR_QUERIES:-5G}"
    export QLEVER_SERVER_CACHE_MAX_SIZE="${QLEVER_SERVER_CACHE_MAX_SIZE:-2G}"
    export QLEVER_SERVER_TIMEOUT="${QLEVER_SERVER_TIMEOUT:-30s}"

    export QLEVER_RUNTIME_SYSTEM="${QLEVER_RUNTIME_SYSTEM:-native}"

    export QLEVER_UI_UI_CONFIG="${QLEVER_UI_UI_CONFIG:-default}"
    export QLEVER_UI_UI_PORT="${QLEVER_UI_UI_PORT:-7002}"

    # Extract all environment variables that start with 'QLEVER_', as we ignore all other variables
    QLEVER_ENV_VARS="$(env | grep '^QLEVER_' | sort -u)"

    # Generate a specific section for the Qleverfile (corrected, POSIX-safe)
    generate_config_section () {
      section="$1"
      section_upper="$(echo "${section}" | tr '[:lower:]' '[:upper:]')"

      # Extract all environment variables for the given section
      section_env_vars="$(echo "${QLEVER_ENV_VARS}" | grep "^QLEVER_${section_upper}_" | sed "s/^QLEVER_${section_upper}_//")"

      # Skip empty sections
      if [ -z "${section_env_vars}" ]; then
        return
      fi

      echo "[$section]"
      echo "${section_env_vars}"
      echo ""
    }

    # Generate the Qleverfile, with the different sections
    {
      echo "# Qleverfile auto-generated using environment variables at $(date), while starting the container"
      echo ""

      generate_config_section "data"
      generate_config_section "index"
      generate_config_section "server"
      generate_config_section "runtime"
      generate_config_section "ui"
    } > "${QLEVER_FILE_PATH}" || exit 1

    echo "INFO: Generated Qleverfile at '${QLEVER_FILE_PATH}'"

    exit 0

  entrypoint.sh: |
    #!/bin/bash
    set -euo pipefail

    # Tweak indexing
    SHOULD_INDEX="${SHOULD_INDEX:-false}"
    FORCE_INDEXING="${FORCE_INDEXING:-false}"

    # Tweak data download
    SHOULD_DOWNLOAD="${SHOULD_DOWNLOAD:-true}"
    FORCE_DOWNLOAD="${FORCE_DOWNLOAD:-false}"

    # Additional parameters to qlever start (e.g. --kill-existing-with-same-port)
    START_ADDITIONAL_ARGS="${START_ADDITIONAL_ARGS:-}"
    STOP_ON_CALL_ENABLED="${STOP_ON_CALL_ENABLED:-false}"

    # Display some debug information
    echo "INFO: Indexing : should index = ${SHOULD_INDEX} ; force indexing = ${FORCE_INDEXING}"
    echo "INFO: Data download : should download = ${SHOULD_DOWNLOAD} ; force download = ${FORCE_DOWNLOAD}"

    # Wait briefly for /data to become writable (named volumes are often root-owned at first).
    echo "UID=$(id -u)"
    echo "GID=$(id -g)"
    ls -al /

    # Generate Qleverfile (or skip, depending on QLEVER_GENERATE_CONFIG_FILE)
    /bin/sh /qlever/scripts/generate-qleverfile.sh

    # Go to the data directory
    cd /data

    QLEVER_FILE_PATH="${QLEVER_FILE_PATH:-/data/Qleverfile}"

    # Check if the Qleverfile exists
    if [ ! -f "${QLEVER_FILE_PATH}" ]; then
      echo "ERROR: Qleverfile not found at '${QLEVER_FILE_PATH}'"
      exit 1
    fi

    # Display the Qleverfile for debugging
    echo "INFO: Qleverfile found at '${QLEVER_FILE_PATH}'"
    cat "${QLEVER_FILE_PATH}"

    # Extract INPUT_FILES from the Qleverfile (if any)
    INPUT_FILES=$(grep "^INPUT_FILES[[:space:]]*=" "${QLEVER_FILE_PATH}" | head -n1 | sed 's/.*=[[:space:]]*//')
    HAS_INPUT_FILES=$(echo "${INPUT_FILES}" | sed '/^[[:space:]]*$/d' | wc -l)

    if [ "${HAS_INPUT_FILES}" -ne 0 ]; then
      echo "INFO: Found 'INPUT_FILES' in the Qleverfile"

      # Check if the input files already exist
      HAS_MISSING_INPUT_FILES="false"
      for INPUT_FILE in ${INPUT_FILES}; do
        if [ -f "${INPUT_FILE}" ]; then
          echo "INFO: Input file found at '${INPUT_FILE}'"
        else
          echo "INFO: Input file not found at '${INPUT_FILE}'"
          HAS_MISSING_INPUT_FILES="true"
        fi
      done

      # If all files are present, skip the download
      if [ "${HAS_MISSING_INPUT_FILES}" = "false" ]; then
        SHOULD_DOWNLOAD="false" # As the input files are already present, no need to download them
      fi

      # Display the info in the logs only if the download is enabled
      if [ "${SHOULD_DOWNLOAD}" = "true" ]; then
        echo "INFO: Trigger download of input files…"
      fi
    fi

    # If the download of the input files is forced, then download them in all cases
    if [ "${FORCE_DOWNLOAD}" = "true" ]; then
      echo "INFO: Forcing download of input files…"
      SHOULD_DOWNLOAD="true"
    fi

    # Check if there is a line that starts with `GET_DATA_CMD` in the Qleverfile
    if grep -q "^GET_DATA_CMD" "${QLEVER_FILE_PATH}"; then
      echo "INFO: Found 'GET_DATA_CMD' in the Qleverfile"
      if [ "${SHOULD_DOWNLOAD}" = "true" ]; then
        echo "INFO: Trigger download of data…"
        qlever get-data
        SHOULD_INDEX="true" # As the data is downloaded, we should index it
      else
        echo "INFO: Skipping download of data…"
      fi
    fi

    # Indexing logic
    if [ "${SHOULD_INDEX}" = "true" ]; then
      echo "INFO: Indexing is enabled"
      qlever index --overwrite-existing
    elif [ "${FORCE_INDEXING}" = "true" ]; then
      echo "INFO: Forcing indexing"
      qlever index --overwrite-existing
    else
      echo "INFO: Indexing is disabled"
    fi

    # Start the QLever server
    echo "INFO: Starting QLever server..."
    if [ "${STOP_ON_CALL_ENABLED}" = "true" ]; then

      # Start QLever in the background
      qlever start --run-in-foreground $START_ADDITIONAL_ARGS &
      QLEVER_PID=$!

      # Start stop_on_call in the background
      stop_on_call &
      STOP_ON_CALL_PID=$!

      # Wait for either QLever or stop_on_call to exit
      wait -n $QLEVER_PID $STOP_ON_CALL_PID
      EXITED_PID=$?

      # Check which one exited
      if ! kill -0 $QLEVER_PID 2>/dev/null; then
        # QLever exited
        wait $QLEVER_PID
        QLEVER_EXIT_CODE=$?
        echo "qlever exited with code $QLEVER_EXIT_CODE"
        kill $STOP_ON_CALL_PID 2>/dev/null
        exit $QLEVER_EXIT_CODE
      else
        # stop_on_call was called, so we stop QLever
        echo ""
        echo ""
        echo ""
        echo "[INFO] Stopped using stop_on_call"
        qlever stop

        # Stop QLever manually, in case it is still running (it should not be, but just in case)
        kill $QLEVER_PID 2>/dev/null || true
        wait $QLEVER_PID || true
        exit 0
      fi

    else
      # Normal case: keep QLever in the foreground, container stays alive
      exec qlever start --run-in-foreground $START_ADDITIONAL_ARGS
    fi